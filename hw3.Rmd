# ---
# title: "HW3"
# author: "Yerui Huang"
# date: "2024-11-3"
# output:
#   pdf_document:
#     latex_engine: xelatex
# ---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup
```{r}
X<- read.table('face.txt',sep = ' ',header = FALSE)
X <-as.matrix(X)
print(length(X))
```
## Question1
```{r}

training_set <- X[1:2100, ]
test_set <- X[2101:2429, ]

mean_face <- colMeans(training_set)
centered_training_set <- training_set - matrix(rep(mean_face, nrow(training_set)), nrow = nrow(training_set), byrow = TRUE)


Sigma <- t(centered_training_set) %*% centered_training_set 

num_eigen <- 20
p <- ncol(Sigma)
eigen_values <- numeric(num_eigen)
eigen_vectors <- matrix(0, nrow = p, ncol = num_eigen)
#ai used
for (k in 1:num_eigen) {
  v <- rnorm(p)
  v <- v / sqrt(sum(v^2))  # 单位化

  # 幂迭代过程，寻找第k个最大的特征值和对应的特征向量
  for (i in 1:1000) {  # 最大迭代次数
    v_new <- Sigma %*% v
    v_new_norm <- sqrt(sum(v_new^2))
    v_new <- v_new / v_new_norm

    # 检查收敛性
    if (sum((v_new - v)^2) < 1e-6) {
      v <- v_new
      break
    }
    v <- v_new
  }

  # 计算特征值
  lambda <- as.numeric(t(v) %*% Sigma %*% v)
  eigen_values[k] <- lambda
  eigen_vectors[, k] <- v

  # 从协方差矩阵中移除已找到的特征值和特征向量的贡献（降维）
  Sigma <- Sigma - lambda * (v %*% t(v))
}

# 将特征向量赋值给 eigen_faces 以便后续使用
eigen_faces <- eigen_vectors

# 输出前20个特征值和对应的特征向量
print("前20个特征值:")
print(eigen_values)
print("前20个特征向量 (特征脸):")
print(eigen_vectors)

# Step 4: 中心化测试集图像
centered_test_set <- test_set - matrix(rep(mean_face, nrow(test_set)), nrow = nrow(test_set), byrow = TRUE)

# Step 5: 使用前K个特征脸进行重构，并计算重构误差
reconstruction_errors <- numeric(5)
k_values <- c(1, 5, 10, 15, 20)

for (i in seq_along(k_values)) {
  k <- k_values[i]
  
  # 将中心化的测试图像投影到前k个特征脸上
  projections <- centered_test_set %*% eigen_faces[, 1:k]
  
  # 从投影重构测试图像
  reconstructed_test_set <- projections %*% t(eigen_faces[, 1:k])
  
  # 加回均值脸以得到最终重构图像
  reconstructed_test_set <- reconstructed_test_set + matrix(rep(mean_face, nrow(reconstructed_test_set)), nrow = nrow(reconstructed_test_set), byrow = TRUE)
  
  # 计算每个测试图像的重构误差（归一化每个像素的误差）
  errors <- rowSums((test_set - reconstructed_test_set)^2) / ncol(test_set)
  
  reconstruction_errors[i] <- mean(errors)
}

plot(k_values, reconstruction_errors, type = 'b', 
     xlab = 'Number of Eigen-faces K', 
     ylab = 'Reconstruction Error per Pixel', 
     main = 'Reconstruction Error over Number of Eigen-faces')


img_height <- 19  
img_width <- 19   


par(mfrow = c(1, 1))  
for (i in 1:10) {
  eigen_face <- matrix(eigen_faces[, i], nrow = img_height, ncol = img_width)
  
 
  eigen_face_norm <- (eigen_face - min(eigen_face)) / (max(eigen_face) - min(eigen_face))
  
  image(eigen_face_norm, col = gray.colors(256), 
        main = paste("Eigen-Face", i), axes = FALSE)
}


par(mfrow = c(1, 1))  
for (i in 1:10) {
 
  original_face <- matrix(test_set[i, ], nrow = img_height, ncol = img_width)

  original_face_norm <- (original_face - min(original_face)) / (max(original_face) - min(original_face))
  
  image(original_face_norm, col = gray.colors(256), 
        main = paste("Original", i), axes = FALSE)
  
  projection <- centered_test_set[i, ] %*% eigen_faces[, 1:20]
  reconstructed_face <- projection %*% t(eigen_faces[, 1:20]) + mean_face
  reconstructed_face <- matrix(reconstructed_face, nrow = img_height, ncol = img_width)
  

  reconstructed_face_norm <- (reconstructed_face - min(reconstructed_face)) / (max(reconstructed_face) - min(reconstructed_face))
  
  image(reconstructed_face_norm, col = gray.colors(256), 
        main = paste("Reconstructed", i), axes = FALSE)
}


```
## Question 3
```{r}

# 设置 K 的不同值
k_values <- c(1, 5, 10, 15, 20)

# 存储不同 K 值下的重建误差
reconstruction_errors <- numeric(length(k_values))

# 对每个 K 值，计算对应的重建误差
for (i in 1:length(k_values)) {
  k <- k_values[i]
  
  # 使用前 K 个特征脸对测试集图像进行重建
  projections <- centered_test_set %*% eigen_faces[, 1:k]
  reconstructed_test_set <- projections %*% t(eigen_faces[, 1:k])
  reconstructed_test_set <- reconstructed_test_set + matrix(rep(mean_face, nrow(reconstructed_test_set)), nrow=nrow(reconstructed_test_set), byrow=TRUE)
  
  # 计算每个像素的重建误差（平方强度差）
  errors <- rowSums((test_set - reconstructed_test_set) ^ 2) / ncol(test_set)
  
  # 计算所有测试图像的平均重建误差
  reconstruction_errors[i] <- mean(errors)
}

# 绘制 K 值与重建误差的关系图
plot(k_values, reconstruction_errors, type = 'b', col = 'blue', pch = 19, xlab = 'Number of Eigen-faces (K)', ylab = 'Reconstruction Error per Pixel', 
     main = 'Reconstruction Error per Pixel vs. Number of Eigen-faces')
grid()

```
